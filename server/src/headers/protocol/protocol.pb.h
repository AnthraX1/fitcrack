// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
namespace proto {
class ConnectResponse;
class ConnectResponseDefaultTypeInternal;
extern ConnectResponseDefaultTypeInternal _ConnectResponse_default_instance_;
class CrackingResponse;
class CrackingResponseDefaultTypeInternal;
extern CrackingResponseDefaultTypeInternal _CrackingResponse_default_instance_;
class CrackingResponse_HashesEntry_DoNotUse;
class CrackingResponse_HashesEntry_DoNotUseDefaultTypeInternal;
extern CrackingResponse_HashesEntry_DoNotUseDefaultTypeInternal _CrackingResponse_HashesEntry_DoNotUse_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Grammar;
class GrammarDefaultTypeInternal;
extern GrammarDefaultTypeInternal _Grammar_default_instance_;
class Grammar_MappingEntry_DoNotUse;
class Grammar_MappingEntry_DoNotUseDefaultTypeInternal;
extern Grammar_MappingEntry_DoNotUseDefaultTypeInternal _Grammar_MappingEntry_DoNotUse_default_instance_;
class IntMap;
class IntMapDefaultTypeInternal;
extern IntMapDefaultTypeInternal _IntMap_default_instance_;
class IntMap_ValueEntry_DoNotUse;
class IntMap_ValueEntry_DoNotUseDefaultTypeInternal;
extern IntMap_ValueEntry_DoNotUseDefaultTypeInternal _IntMap_ValueEntry_DoNotUse_default_instance_;
class Items;
class ItemsDefaultTypeInternal;
extern ItemsDefaultTypeInternal _Items_default_instance_;
class NextRequest;
class NextRequestDefaultTypeInternal;
extern NextRequestDefaultTypeInternal _NextRequest_default_instance_;
class Replacement;
class ReplacementDefaultTypeInternal;
extern ReplacementDefaultTypeInternal _Replacement_default_instance_;
class ResultResponse;
class ResultResponseDefaultTypeInternal;
extern ResultResponseDefaultTypeInternal _ResultResponse_default_instance_;
class Section;
class SectionDefaultTypeInternal;
extern SectionDefaultTypeInternal _Section_default_instance_;
class TreeItem;
class TreeItemDefaultTypeInternal;
extern TreeItemDefaultTypeInternal _TreeItem_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::ConnectResponse* Arena::CreateMaybeMessage<::proto::ConnectResponse>(Arena*);
template<> ::proto::CrackingResponse* Arena::CreateMaybeMessage<::proto::CrackingResponse>(Arena*);
template<> ::proto::CrackingResponse_HashesEntry_DoNotUse* Arena::CreateMaybeMessage<::proto::CrackingResponse_HashesEntry_DoNotUse>(Arena*);
template<> ::proto::Empty* Arena::CreateMaybeMessage<::proto::Empty>(Arena*);
template<> ::proto::Grammar* Arena::CreateMaybeMessage<::proto::Grammar>(Arena*);
template<> ::proto::Grammar_MappingEntry_DoNotUse* Arena::CreateMaybeMessage<::proto::Grammar_MappingEntry_DoNotUse>(Arena*);
template<> ::proto::IntMap* Arena::CreateMaybeMessage<::proto::IntMap>(Arena*);
template<> ::proto::IntMap_ValueEntry_DoNotUse* Arena::CreateMaybeMessage<::proto::IntMap_ValueEntry_DoNotUse>(Arena*);
template<> ::proto::Items* Arena::CreateMaybeMessage<::proto::Items>(Arena*);
template<> ::proto::NextRequest* Arena::CreateMaybeMessage<::proto::NextRequest>(Arena*);
template<> ::proto::Replacement* Arena::CreateMaybeMessage<::proto::Replacement>(Arena*);
template<> ::proto::ResultResponse* Arena::CreateMaybeMessage<::proto::ResultResponse>(Arena*);
template<> ::proto::Section* Arena::CreateMaybeMessage<::proto::Section>(Arena*);
template<> ::proto::TreeItem* Arena::CreateMaybeMessage<::proto::TreeItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class Empty :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(nullptr);
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Empty";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.Empty)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class NextRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.NextRequest) */ {
 public:
  NextRequest();
  virtual ~NextRequest();

  NextRequest(const NextRequest& from);
  NextRequest(NextRequest&& from) noexcept
    : NextRequest() {
    *this = ::std::move(from);
  }

  inline NextRequest& operator=(const NextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextRequest& operator=(NextRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NextRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NextRequest* internal_default_instance() {
    return reinterpret_cast<const NextRequest*>(
               &_NextRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NextRequest* other);
  friend void swap(NextRequest& a, NextRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NextRequest* New() const final {
    return CreateMaybeMessage<NextRequest>(nullptr);
  }

  NextRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NextRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NextRequest& from);
  void MergeFrom(const NextRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.NextRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 terminals = 1;
  void clear_terminals();
  static const int kTerminalsFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 terminals() const;
  void set_terminals(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.NextRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 terminals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class ConnectResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ConnectResponse) */ {
 public:
  ConnectResponse();
  virtual ~ConnectResponse();

  ConnectResponse(const ConnectResponse& from);
  ConnectResponse(ConnectResponse&& from) noexcept
    : ConnectResponse() {
    *this = ::std::move(from);
  }

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectResponse& operator=(ConnectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectResponse*>(
               &_ConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ConnectResponse* other);
  friend void swap(ConnectResponse& a, ConnectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectResponse* New() const final {
    return CreateMaybeMessage<ConnectResponse>(nullptr);
  }

  ConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectResponse& from);
  void MergeFrom(const ConnectResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ConnectResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string hashList = 2;
  int hashlist_size() const;
  void clear_hashlist();
  static const int kHashListFieldNumber = 2;
  const std::string& hashlist(int index) const;
  std::string* mutable_hashlist(int index);
  void set_hashlist(int index, const std::string& value);
  void set_hashlist(int index, std::string&& value);
  void set_hashlist(int index, const char* value);
  void set_hashlist(int index, const char* value, size_t size);
  std::string* add_hashlist();
  void add_hashlist(const std::string& value);
  void add_hashlist(std::string&& value);
  void add_hashlist(const char* value);
  void add_hashlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashlist();

  // string hashcatMode = 3;
  void clear_hashcatmode();
  static const int kHashcatModeFieldNumber = 3;
  const std::string& hashcatmode() const;
  void set_hashcatmode(const std::string& value);
  void set_hashcatmode(std::string&& value);
  void set_hashcatmode(const char* value);
  void set_hashcatmode(const char* value, size_t size);
  std::string* mutable_hashcatmode();
  std::string* release_hashcatmode();
  void set_allocated_hashcatmode(std::string* hashcatmode);

  // .proto.Grammar grammar = 1;
  bool has_grammar() const;
  void clear_grammar();
  static const int kGrammarFieldNumber = 1;
  const ::proto::Grammar& grammar() const;
  ::proto::Grammar* release_grammar();
  ::proto::Grammar* mutable_grammar();
  void set_allocated_grammar(::proto::Grammar* grammar);

  // @@protoc_insertion_point(class_scope:proto.ConnectResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashcatmode_;
  ::proto::Grammar* grammar_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class ResultResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ResultResponse) */ {
 public:
  ResultResponse();
  virtual ~ResultResponse();

  ResultResponse(const ResultResponse& from);
  ResultResponse(ResultResponse&& from) noexcept
    : ResultResponse() {
    *this = ::std::move(from);
  }

  inline ResultResponse& operator=(const ResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultResponse& operator=(ResultResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResultResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultResponse* internal_default_instance() {
    return reinterpret_cast<const ResultResponse*>(
               &_ResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResultResponse* other);
  friend void swap(ResultResponse& a, ResultResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultResponse* New() const final {
    return CreateMaybeMessage<ResultResponse>(nullptr);
  }

  ResultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResultResponse& from);
  void MergeFrom(const ResultResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ResultResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool end = 1;
  void clear_end();
  static const int kEndFieldNumber = 1;
  bool end() const;
  void set_end(bool value);

  // @@protoc_insertion_point(class_scope:proto.ResultResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class CrackingResponse_HashesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CrackingResponse_HashesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CrackingResponse_HashesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CrackingResponse_HashesEntry_DoNotUse();
  CrackingResponse_HashesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CrackingResponse_HashesEntry_DoNotUse& other);
  static const CrackingResponse_HashesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CrackingResponse_HashesEntry_DoNotUse*>(&_CrackingResponse_HashesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "proto.CrackingResponse.HashesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "proto.CrackingResponse.HashesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class CrackingResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.CrackingResponse) */ {
 public:
  CrackingResponse();
  virtual ~CrackingResponse();

  CrackingResponse(const CrackingResponse& from);
  CrackingResponse(CrackingResponse&& from) noexcept
    : CrackingResponse() {
    *this = ::std::move(from);
  }

  inline CrackingResponse& operator=(const CrackingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrackingResponse& operator=(CrackingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrackingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrackingResponse* internal_default_instance() {
    return reinterpret_cast<const CrackingResponse*>(
               &_CrackingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CrackingResponse* other);
  friend void swap(CrackingResponse& a, CrackingResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrackingResponse* New() const final {
    return CreateMaybeMessage<CrackingResponse>(nullptr);
  }

  CrackingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrackingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrackingResponse& from);
  void MergeFrom(const CrackingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrackingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.CrackingResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> hashes = 1;
  int hashes_size() const;
  void clear_hashes();
  static const int kHashesFieldNumber = 1;
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      hashes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_hashes();

  // @@protoc_insertion_point(class_scope:proto.CrackingResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CrackingResponse_HashesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > hashes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Grammar_MappingEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Grammar_MappingEntry_DoNotUse, 
    std::string, ::proto::IntMap,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Grammar_MappingEntry_DoNotUse, 
    std::string, ::proto::IntMap,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Grammar_MappingEntry_DoNotUse();
  Grammar_MappingEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Grammar_MappingEntry_DoNotUse& other);
  static const Grammar_MappingEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Grammar_MappingEntry_DoNotUse*>(&_Grammar_MappingEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "proto.Grammar.MappingEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class Grammar :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Grammar) */ {
 public:
  Grammar();
  virtual ~Grammar();

  Grammar(const Grammar& from);
  Grammar(Grammar&& from) noexcept
    : Grammar() {
    *this = ::std::move(from);
  }

  inline Grammar& operator=(const Grammar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grammar& operator=(Grammar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Grammar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Grammar* internal_default_instance() {
    return reinterpret_cast<const Grammar*>(
               &_Grammar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Grammar* other);
  friend void swap(Grammar& a, Grammar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Grammar* New() const final {
    return CreateMaybeMessage<Grammar>(nullptr);
  }

  Grammar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Grammar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Grammar& from);
  void MergeFrom(const Grammar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grammar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Grammar";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .proto.Section sections = 2;
  int sections_size() const;
  void clear_sections();
  static const int kSectionsFieldNumber = 2;
  ::proto::Section* mutable_sections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >*
      mutable_sections();
  const ::proto::Section& sections(int index) const;
  ::proto::Section* add_sections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >&
      sections() const;

  // map<string, .proto.IntMap> mapping = 3;
  int mapping_size() const;
  void clear_mapping();
  static const int kMappingFieldNumber = 3;
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::proto::IntMap >&
      mapping() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::proto::IntMap >*
      mutable_mapping();

  // string rulesFolder = 1;
  void clear_rulesfolder();
  static const int kRulesFolderFieldNumber = 1;
  const std::string& rulesfolder() const;
  void set_rulesfolder(const std::string& value);
  void set_rulesfolder(std::string&& value);
  void set_rulesfolder(const char* value);
  void set_rulesfolder(const char* value, size_t size);
  std::string* mutable_rulesfolder();
  std::string* release_rulesfolder();
  void set_allocated_rulesfolder(std::string* rulesfolder);

  // @@protoc_insertion_point(class_scope:proto.Grammar)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section > sections_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Grammar_MappingEntry_DoNotUse,
      std::string, ::proto::IntMap,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > mapping_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rulesfolder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class IntMap_ValueEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IntMap_ValueEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IntMap_ValueEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  IntMap_ValueEntry_DoNotUse();
  IntMap_ValueEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const IntMap_ValueEntry_DoNotUse& other);
  static const IntMap_ValueEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IntMap_ValueEntry_DoNotUse*>(&_IntMap_ValueEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "proto.IntMap.ValueEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class IntMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.IntMap) */ {
 public:
  IntMap();
  virtual ~IntMap();

  IntMap(const IntMap& from);
  IntMap(IntMap&& from) noexcept
    : IntMap() {
    *this = ::std::move(from);
  }

  inline IntMap& operator=(const IntMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntMap& operator=(IntMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntMap* internal_default_instance() {
    return reinterpret_cast<const IntMap*>(
               &_IntMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(IntMap* other);
  friend void swap(IntMap& a, IntMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntMap* New() const final {
    return CreateMaybeMessage<IntMap>(nullptr);
  }

  IntMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntMap& from);
  void MergeFrom(const IntMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.IntMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, int32> value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:proto.IntMap)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      IntMap_ValueEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      0 > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Replacement :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Replacement) */ {
 public:
  Replacement();
  virtual ~Replacement();

  Replacement(const Replacement& from);
  Replacement(Replacement&& from) noexcept
    : Replacement() {
    *this = ::std::move(from);
  }

  inline Replacement& operator=(const Replacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replacement& operator=(Replacement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Replacement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Replacement* internal_default_instance() {
    return reinterpret_cast<const Replacement*>(
               &_Replacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Replacement* other);
  friend void swap(Replacement& a, Replacement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Replacement* New() const final {
    return CreateMaybeMessage<Replacement>(nullptr);
  }

  Replacement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Replacement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Replacement& from);
  void MergeFrom(const Replacement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Replacement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Replacement";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();

  // repeated int32 pos = 5;
  int pos_size() const;
  void clear_pos();
  static const int kPosFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 pos(int index) const;
  void set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_pos(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_pos();

  // string function = 4;
  void clear_function();
  static const int kFunctionFieldNumber = 4;
  const std::string& function() const;
  void set_function(const std::string& value);
  void set_function(std::string&& value);
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  std::string* mutable_function();
  std::string* release_function();
  void set_allocated_function(std::string* function);

  // double probability = 1;
  void clear_probability();
  static const int kProbabilityFieldNumber = 1;
  double probability() const;
  void set_probability(double value);

  // bool isTerminal = 2;
  void clear_isterminal();
  static const int kIsTerminalFieldNumber = 2;
  bool isterminal() const;
  void set_isterminal(bool value);

  // @@protoc_insertion_point(class_scope:proto.Replacement)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > pos_;
  mutable std::atomic<int> _pos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  double probability_;
  bool isterminal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Section :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Section) */ {
 public:
  Section();
  virtual ~Section();

  Section(const Section& from);
  Section(Section&& from) noexcept
    : Section() {
    *this = ::std::move(from);
  }

  inline Section& operator=(const Section& from) {
    CopyFrom(from);
    return *this;
  }
  inline Section& operator=(Section&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Section& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Section* internal_default_instance() {
    return reinterpret_cast<const Section*>(
               &_Section_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Section* other);
  friend void swap(Section& a, Section& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Section* New() const final {
    return CreateMaybeMessage<Section>(nullptr);
  }

  Section* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Section>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Section& from);
  void MergeFrom(const Section& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Section* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Section";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Replacement replacements = 3;
  int replacements_size() const;
  void clear_replacements();
  static const int kReplacementsFieldNumber = 3;
  ::proto::Replacement* mutable_replacements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Replacement >*
      mutable_replacements();
  const ::proto::Replacement& replacements(int index) const;
  ::proto::Replacement* add_replacements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Replacement >&
      replacements() const;

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:proto.Section)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Replacement > replacements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class Items :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Items) */ {
 public:
  Items();
  virtual ~Items();

  Items(const Items& from);
  Items(Items&& from) noexcept
    : Items() {
    *this = ::std::move(from);
  }

  inline Items& operator=(const Items& from) {
    CopyFrom(from);
    return *this;
  }
  inline Items& operator=(Items&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Items& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Items* internal_default_instance() {
    return reinterpret_cast<const Items*>(
               &_Items_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Items* other);
  friend void swap(Items& a, Items& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Items* New() const final {
    return CreateMaybeMessage<Items>(nullptr);
  }

  Items* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Items>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Items& from);
  void MergeFrom(const Items& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Items* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Items";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.TreeItem preTerminals = 1;
  int preterminals_size() const;
  void clear_preterminals();
  static const int kPreTerminalsFieldNumber = 1;
  ::proto::TreeItem* mutable_preterminals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >*
      mutable_preterminals();
  const ::proto::TreeItem& preterminals(int index) const;
  ::proto::TreeItem* add_preterminals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >&
      preterminals() const;

  // repeated string terminals = 2;
  int terminals_size() const;
  void clear_terminals();
  static const int kTerminalsFieldNumber = 2;
  const std::string& terminals(int index) const;
  std::string* mutable_terminals(int index);
  void set_terminals(int index, const std::string& value);
  void set_terminals(int index, std::string&& value);
  void set_terminals(int index, const char* value);
  void set_terminals(int index, const char* value, size_t size);
  std::string* add_terminals();
  void add_terminals(const std::string& value);
  void add_terminals(std::string&& value);
  void add_terminals(const char* value);
  void add_terminals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& terminals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_terminals();

  // uint64 terminalsCount = 3;
  void clear_terminalscount();
  static const int kTerminalsCountFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 terminalscount() const;
  void set_terminalscount(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.Items)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem > preterminals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> terminals_;
  ::PROTOBUF_NAMESPACE_ID::uint64 terminalscount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class TreeItem :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.TreeItem) */ {
 public:
  TreeItem();
  virtual ~TreeItem();

  TreeItem(const TreeItem& from);
  TreeItem(TreeItem&& from) noexcept
    : TreeItem() {
    *this = ::std::move(from);
  }

  inline TreeItem& operator=(const TreeItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeItem& operator=(TreeItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TreeItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeItem* internal_default_instance() {
    return reinterpret_cast<const TreeItem*>(
               &_TreeItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TreeItem* other);
  friend void swap(TreeItem& a, TreeItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreeItem* New() const final {
    return CreateMaybeMessage<TreeItem>(nullptr);
  }

  TreeItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TreeItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TreeItem& from);
  void MergeFrom(const TreeItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.TreeItem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.TreeItem childrens = 3;
  int childrens_size() const;
  void clear_childrens();
  static const int kChildrensFieldNumber = 3;
  ::proto::TreeItem* mutable_childrens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >*
      mutable_childrens();
  const ::proto::TreeItem& childrens(int index) const;
  ::proto::TreeItem* add_childrens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >&
      childrens() const;

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 transition = 2;
  void clear_transition();
  static const int kTransitionFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 transition() const;
  void set_transition(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  bool id() const;
  void set_id(bool value);

  // @@protoc_insertion_point(class_scope:proto.TreeItem)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem > childrens_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  ::PROTOBUF_NAMESPACE_ID::int32 transition_;
  bool id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// NextRequest

// uint64 terminals = 1;
inline void NextRequest::clear_terminals() {
  terminals_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NextRequest::terminals() const {
  // @@protoc_insertion_point(field_get:proto.NextRequest.terminals)
  return terminals_;
}
inline void NextRequest::set_terminals(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  terminals_ = value;
  // @@protoc_insertion_point(field_set:proto.NextRequest.terminals)
}

// -------------------------------------------------------------------

// ConnectResponse

// .proto.Grammar grammar = 1;
inline bool ConnectResponse::has_grammar() const {
  return this != internal_default_instance() && grammar_ != nullptr;
}
inline void ConnectResponse::clear_grammar() {
  if (GetArenaNoVirtual() == nullptr && grammar_ != nullptr) {
    delete grammar_;
  }
  grammar_ = nullptr;
}
inline const ::proto::Grammar& ConnectResponse::grammar() const {
  const ::proto::Grammar* p = grammar_;
  // @@protoc_insertion_point(field_get:proto.ConnectResponse.grammar)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::Grammar*>(
      &::proto::_Grammar_default_instance_);
}
inline ::proto::Grammar* ConnectResponse::release_grammar() {
  // @@protoc_insertion_point(field_release:proto.ConnectResponse.grammar)
  
  ::proto::Grammar* temp = grammar_;
  grammar_ = nullptr;
  return temp;
}
inline ::proto::Grammar* ConnectResponse::mutable_grammar() {
  
  if (grammar_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Grammar>(GetArenaNoVirtual());
    grammar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.ConnectResponse.grammar)
  return grammar_;
}
inline void ConnectResponse::set_allocated_grammar(::proto::Grammar* grammar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete grammar_;
  }
  if (grammar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      grammar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grammar, submessage_arena);
    }
    
  } else {
    
  }
  grammar_ = grammar;
  // @@protoc_insertion_point(field_set_allocated:proto.ConnectResponse.grammar)
}

// repeated string hashList = 2;
inline int ConnectResponse::hashlist_size() const {
  return hashlist_.size();
}
inline void ConnectResponse::clear_hashlist() {
  hashlist_.Clear();
}
inline const std::string& ConnectResponse::hashlist(int index) const {
  // @@protoc_insertion_point(field_get:proto.ConnectResponse.hashList)
  return hashlist_.Get(index);
}
inline std::string* ConnectResponse::mutable_hashlist(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ConnectResponse.hashList)
  return hashlist_.Mutable(index);
}
inline void ConnectResponse::set_hashlist(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:proto.ConnectResponse.hashList)
  hashlist_.Mutable(index)->assign(value);
}
inline void ConnectResponse::set_hashlist(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.ConnectResponse.hashList)
  hashlist_.Mutable(index)->assign(std::move(value));
}
inline void ConnectResponse::set_hashlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.ConnectResponse.hashList)
}
inline void ConnectResponse::set_hashlist(int index, const char* value, size_t size) {
  hashlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.ConnectResponse.hashList)
}
inline std::string* ConnectResponse::add_hashlist() {
  // @@protoc_insertion_point(field_add_mutable:proto.ConnectResponse.hashList)
  return hashlist_.Add();
}
inline void ConnectResponse::add_hashlist(const std::string& value) {
  hashlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.ConnectResponse.hashList)
}
inline void ConnectResponse::add_hashlist(std::string&& value) {
  hashlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.ConnectResponse.hashList)
}
inline void ConnectResponse::add_hashlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.ConnectResponse.hashList)
}
inline void ConnectResponse::add_hashlist(const char* value, size_t size) {
  hashlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.ConnectResponse.hashList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConnectResponse::hashlist() const {
  // @@protoc_insertion_point(field_list:proto.ConnectResponse.hashList)
  return hashlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConnectResponse::mutable_hashlist() {
  // @@protoc_insertion_point(field_mutable_list:proto.ConnectResponse.hashList)
  return &hashlist_;
}

// string hashcatMode = 3;
inline void ConnectResponse::clear_hashcatmode() {
  hashcatmode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnectResponse::hashcatmode() const {
  // @@protoc_insertion_point(field_get:proto.ConnectResponse.hashcatMode)
  return hashcatmode_.GetNoArena();
}
inline void ConnectResponse::set_hashcatmode(const std::string& value) {
  
  hashcatmode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ConnectResponse.hashcatMode)
}
inline void ConnectResponse::set_hashcatmode(std::string&& value) {
  
  hashcatmode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ConnectResponse.hashcatMode)
}
inline void ConnectResponse::set_hashcatmode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hashcatmode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ConnectResponse.hashcatMode)
}
inline void ConnectResponse::set_hashcatmode(const char* value, size_t size) {
  
  hashcatmode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ConnectResponse.hashcatMode)
}
inline std::string* ConnectResponse::mutable_hashcatmode() {
  
  // @@protoc_insertion_point(field_mutable:proto.ConnectResponse.hashcatMode)
  return hashcatmode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnectResponse::release_hashcatmode() {
  // @@protoc_insertion_point(field_release:proto.ConnectResponse.hashcatMode)
  
  return hashcatmode_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectResponse::set_allocated_hashcatmode(std::string* hashcatmode) {
  if (hashcatmode != nullptr) {
    
  } else {
    
  }
  hashcatmode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hashcatmode);
  // @@protoc_insertion_point(field_set_allocated:proto.ConnectResponse.hashcatMode)
}

// -------------------------------------------------------------------

// ResultResponse

// bool end = 1;
inline void ResultResponse::clear_end() {
  end_ = false;
}
inline bool ResultResponse::end() const {
  // @@protoc_insertion_point(field_get:proto.ResultResponse.end)
  return end_;
}
inline void ResultResponse::set_end(bool value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:proto.ResultResponse.end)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CrackingResponse

// map<string, string> hashes = 1;
inline int CrackingResponse::hashes_size() const {
  return hashes_.size();
}
inline void CrackingResponse::clear_hashes() {
  hashes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CrackingResponse::hashes() const {
  // @@protoc_insertion_point(field_map:proto.CrackingResponse.hashes)
  return hashes_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CrackingResponse::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_map:proto.CrackingResponse.hashes)
  return hashes_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Grammar

// string rulesFolder = 1;
inline void Grammar::clear_rulesfolder() {
  rulesfolder_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Grammar::rulesfolder() const {
  // @@protoc_insertion_point(field_get:proto.Grammar.rulesFolder)
  return rulesfolder_.GetNoArena();
}
inline void Grammar::set_rulesfolder(const std::string& value) {
  
  rulesfolder_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Grammar.rulesFolder)
}
inline void Grammar::set_rulesfolder(std::string&& value) {
  
  rulesfolder_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Grammar.rulesFolder)
}
inline void Grammar::set_rulesfolder(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rulesfolder_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Grammar.rulesFolder)
}
inline void Grammar::set_rulesfolder(const char* value, size_t size) {
  
  rulesfolder_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Grammar.rulesFolder)
}
inline std::string* Grammar::mutable_rulesfolder() {
  
  // @@protoc_insertion_point(field_mutable:proto.Grammar.rulesFolder)
  return rulesfolder_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Grammar::release_rulesfolder() {
  // @@protoc_insertion_point(field_release:proto.Grammar.rulesFolder)
  
  return rulesfolder_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Grammar::set_allocated_rulesfolder(std::string* rulesfolder) {
  if (rulesfolder != nullptr) {
    
  } else {
    
  }
  rulesfolder_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rulesfolder);
  // @@protoc_insertion_point(field_set_allocated:proto.Grammar.rulesFolder)
}

// repeated .proto.Section sections = 2;
inline int Grammar::sections_size() const {
  return sections_.size();
}
inline void Grammar::clear_sections() {
  sections_.Clear();
}
inline ::proto::Section* Grammar::mutable_sections(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Grammar.sections)
  return sections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >*
Grammar::mutable_sections() {
  // @@protoc_insertion_point(field_mutable_list:proto.Grammar.sections)
  return &sections_;
}
inline const ::proto::Section& Grammar::sections(int index) const {
  // @@protoc_insertion_point(field_get:proto.Grammar.sections)
  return sections_.Get(index);
}
inline ::proto::Section* Grammar::add_sections() {
  // @@protoc_insertion_point(field_add:proto.Grammar.sections)
  return sections_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Section >&
Grammar::sections() const {
  // @@protoc_insertion_point(field_list:proto.Grammar.sections)
  return sections_;
}

// map<string, .proto.IntMap> mapping = 3;
inline int Grammar::mapping_size() const {
  return mapping_.size();
}
inline void Grammar::clear_mapping() {
  mapping_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::proto::IntMap >&
Grammar::mapping() const {
  // @@protoc_insertion_point(field_map:proto.Grammar.mapping)
  return mapping_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::proto::IntMap >*
Grammar::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_map:proto.Grammar.mapping)
  return mapping_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IntMap

// map<string, int32> value = 1;
inline int IntMap::value_size() const {
  return value_.size();
}
inline void IntMap::clear_value() {
  value_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >&
IntMap::value() const {
  // @@protoc_insertion_point(field_map:proto.IntMap.value)
  return value_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >*
IntMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable_map:proto.IntMap.value)
  return value_.MutableMap();
}

// -------------------------------------------------------------------

// Replacement

// double probability = 1;
inline void Replacement::clear_probability() {
  probability_ = 0;
}
inline double Replacement::probability() const {
  // @@protoc_insertion_point(field_get:proto.Replacement.probability)
  return probability_;
}
inline void Replacement::set_probability(double value) {
  
  probability_ = value;
  // @@protoc_insertion_point(field_set:proto.Replacement.probability)
}

// bool isTerminal = 2;
inline void Replacement::clear_isterminal() {
  isterminal_ = false;
}
inline bool Replacement::isterminal() const {
  // @@protoc_insertion_point(field_get:proto.Replacement.isTerminal)
  return isterminal_;
}
inline void Replacement::set_isterminal(bool value) {
  
  isterminal_ = value;
  // @@protoc_insertion_point(field_set:proto.Replacement.isTerminal)
}

// repeated string values = 3;
inline int Replacement::values_size() const {
  return values_.size();
}
inline void Replacement::clear_values() {
  values_.Clear();
}
inline const std::string& Replacement::values(int index) const {
  // @@protoc_insertion_point(field_get:proto.Replacement.values)
  return values_.Get(index);
}
inline std::string* Replacement::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Replacement.values)
  return values_.Mutable(index);
}
inline void Replacement::set_values(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:proto.Replacement.values)
  values_.Mutable(index)->assign(value);
}
inline void Replacement::set_values(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.Replacement.values)
  values_.Mutable(index)->assign(std::move(value));
}
inline void Replacement::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.Replacement.values)
}
inline void Replacement::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.Replacement.values)
}
inline std::string* Replacement::add_values() {
  // @@protoc_insertion_point(field_add_mutable:proto.Replacement.values)
  return values_.Add();
}
inline void Replacement::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.Replacement.values)
}
inline void Replacement::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.Replacement.values)
}
inline void Replacement::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.Replacement.values)
}
inline void Replacement::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.Replacement.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Replacement::values() const {
  // @@protoc_insertion_point(field_list:proto.Replacement.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Replacement::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:proto.Replacement.values)
  return &values_;
}

// string function = 4;
inline void Replacement::clear_function() {
  function_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Replacement::function() const {
  // @@protoc_insertion_point(field_get:proto.Replacement.function)
  return function_.GetNoArena();
}
inline void Replacement::set_function(const std::string& value) {
  
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Replacement.function)
}
inline void Replacement::set_function(std::string&& value) {
  
  function_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Replacement.function)
}
inline void Replacement::set_function(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Replacement.function)
}
inline void Replacement::set_function(const char* value, size_t size) {
  
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Replacement.function)
}
inline std::string* Replacement::mutable_function() {
  
  // @@protoc_insertion_point(field_mutable:proto.Replacement.function)
  return function_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Replacement::release_function() {
  // @@protoc_insertion_point(field_release:proto.Replacement.function)
  
  return function_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Replacement::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    
  } else {
    
  }
  function_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:proto.Replacement.function)
}

// repeated int32 pos = 5;
inline int Replacement::pos_size() const {
  return pos_.size();
}
inline void Replacement::clear_pos() {
  pos_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Replacement::pos(int index) const {
  // @@protoc_insertion_point(field_get:proto.Replacement.pos)
  return pos_.Get(index);
}
inline void Replacement::set_pos(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.Replacement.pos)
}
inline void Replacement::add_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  pos_.Add(value);
  // @@protoc_insertion_point(field_add:proto.Replacement.pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Replacement::pos() const {
  // @@protoc_insertion_point(field_list:proto.Replacement.pos)
  return pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Replacement::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:proto.Replacement.pos)
  return &pos_;
}

// -------------------------------------------------------------------

// Section

// string type = 1;
inline void Section::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Section::type() const {
  // @@protoc_insertion_point(field_get:proto.Section.type)
  return type_.GetNoArena();
}
inline void Section::set_type(const std::string& value) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Section.type)
}
inline void Section::set_type(std::string&& value) {
  
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Section.type)
}
inline void Section::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Section.type)
}
inline void Section::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Section.type)
}
inline std::string* Section::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:proto.Section.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Section::release_type() {
  // @@protoc_insertion_point(field_release:proto.Section.type)
  
  return type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Section::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:proto.Section.type)
}

// string name = 2;
inline void Section::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Section::name() const {
  // @@protoc_insertion_point(field_get:proto.Section.name)
  return name_.GetNoArena();
}
inline void Section::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Section.name)
}
inline void Section::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Section.name)
}
inline void Section::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Section.name)
}
inline void Section::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Section.name)
}
inline std::string* Section::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.Section.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Section::release_name() {
  // @@protoc_insertion_point(field_release:proto.Section.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Section::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.Section.name)
}

// repeated .proto.Replacement replacements = 3;
inline int Section::replacements_size() const {
  return replacements_.size();
}
inline void Section::clear_replacements() {
  replacements_.Clear();
}
inline ::proto::Replacement* Section::mutable_replacements(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Section.replacements)
  return replacements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Replacement >*
Section::mutable_replacements() {
  // @@protoc_insertion_point(field_mutable_list:proto.Section.replacements)
  return &replacements_;
}
inline const ::proto::Replacement& Section::replacements(int index) const {
  // @@protoc_insertion_point(field_get:proto.Section.replacements)
  return replacements_.Get(index);
}
inline ::proto::Replacement* Section::add_replacements() {
  // @@protoc_insertion_point(field_add:proto.Section.replacements)
  return replacements_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::Replacement >&
Section::replacements() const {
  // @@protoc_insertion_point(field_list:proto.Section.replacements)
  return replacements_;
}

// -------------------------------------------------------------------

// Items

// repeated .proto.TreeItem preTerminals = 1;
inline int Items::preterminals_size() const {
  return preterminals_.size();
}
inline void Items::clear_preterminals() {
  preterminals_.Clear();
}
inline ::proto::TreeItem* Items::mutable_preterminals(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Items.preTerminals)
  return preterminals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >*
Items::mutable_preterminals() {
  // @@protoc_insertion_point(field_mutable_list:proto.Items.preTerminals)
  return &preterminals_;
}
inline const ::proto::TreeItem& Items::preterminals(int index) const {
  // @@protoc_insertion_point(field_get:proto.Items.preTerminals)
  return preterminals_.Get(index);
}
inline ::proto::TreeItem* Items::add_preterminals() {
  // @@protoc_insertion_point(field_add:proto.Items.preTerminals)
  return preterminals_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >&
Items::preterminals() const {
  // @@protoc_insertion_point(field_list:proto.Items.preTerminals)
  return preterminals_;
}

// repeated string terminals = 2;
inline int Items::terminals_size() const {
  return terminals_.size();
}
inline void Items::clear_terminals() {
  terminals_.Clear();
}
inline const std::string& Items::terminals(int index) const {
  // @@protoc_insertion_point(field_get:proto.Items.terminals)
  return terminals_.Get(index);
}
inline std::string* Items::mutable_terminals(int index) {
  // @@protoc_insertion_point(field_mutable:proto.Items.terminals)
  return terminals_.Mutable(index);
}
inline void Items::set_terminals(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:proto.Items.terminals)
  terminals_.Mutable(index)->assign(value);
}
inline void Items::set_terminals(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.Items.terminals)
  terminals_.Mutable(index)->assign(std::move(value));
}
inline void Items::set_terminals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  terminals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.Items.terminals)
}
inline void Items::set_terminals(int index, const char* value, size_t size) {
  terminals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.Items.terminals)
}
inline std::string* Items::add_terminals() {
  // @@protoc_insertion_point(field_add_mutable:proto.Items.terminals)
  return terminals_.Add();
}
inline void Items::add_terminals(const std::string& value) {
  terminals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.Items.terminals)
}
inline void Items::add_terminals(std::string&& value) {
  terminals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.Items.terminals)
}
inline void Items::add_terminals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  terminals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.Items.terminals)
}
inline void Items::add_terminals(const char* value, size_t size) {
  terminals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.Items.terminals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Items::terminals() const {
  // @@protoc_insertion_point(field_list:proto.Items.terminals)
  return terminals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Items::mutable_terminals() {
  // @@protoc_insertion_point(field_mutable_list:proto.Items.terminals)
  return &terminals_;
}

// uint64 terminalsCount = 3;
inline void Items::clear_terminalscount() {
  terminalscount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Items::terminalscount() const {
  // @@protoc_insertion_point(field_get:proto.Items.terminalsCount)
  return terminalscount_;
}
inline void Items::set_terminalscount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  terminalscount_ = value;
  // @@protoc_insertion_point(field_set:proto.Items.terminalsCount)
}

// -------------------------------------------------------------------

// TreeItem

// int32 index = 1;
inline void TreeItem::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TreeItem::index() const {
  // @@protoc_insertion_point(field_get:proto.TreeItem.index)
  return index_;
}
inline void TreeItem::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.TreeItem.index)
}

// int32 transition = 2;
inline void TreeItem::clear_transition() {
  transition_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TreeItem::transition() const {
  // @@protoc_insertion_point(field_get:proto.TreeItem.transition)
  return transition_;
}
inline void TreeItem::set_transition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  transition_ = value;
  // @@protoc_insertion_point(field_set:proto.TreeItem.transition)
}

// repeated .proto.TreeItem childrens = 3;
inline int TreeItem::childrens_size() const {
  return childrens_.size();
}
inline void TreeItem::clear_childrens() {
  childrens_.Clear();
}
inline ::proto::TreeItem* TreeItem::mutable_childrens(int index) {
  // @@protoc_insertion_point(field_mutable:proto.TreeItem.childrens)
  return childrens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >*
TreeItem::mutable_childrens() {
  // @@protoc_insertion_point(field_mutable_list:proto.TreeItem.childrens)
  return &childrens_;
}
inline const ::proto::TreeItem& TreeItem::childrens(int index) const {
  // @@protoc_insertion_point(field_get:proto.TreeItem.childrens)
  return childrens_.Get(index);
}
inline ::proto::TreeItem* TreeItem::add_childrens() {
  // @@protoc_insertion_point(field_add:proto.TreeItem.childrens)
  return childrens_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::TreeItem >&
TreeItem::childrens() const {
  // @@protoc_insertion_point(field_list:proto.TreeItem.childrens)
  return childrens_;
}

// bool id = 4;
inline void TreeItem::clear_id() {
  id_ = false;
}
inline bool TreeItem::id() const {
  // @@protoc_insertion_point(field_get:proto.TreeItem.id)
  return id_;
}
inline void TreeItem::set_id(bool value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.TreeItem.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
